// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: purchase.sql

package repositories

import (
	"context"

	"github.com/google/uuid"
)

const CreatePurchase = `-- name: CreatePurchase :one
INSERT INTO purchase (
    id, status, customer_id, latest_update
) VALUES (
    uuid_generate_v4(), $1, $2, CURRENT_DATE
)
    RETURNING id, status, customer_id, latest_update
`

type CreatePurchaseParams struct {
	Status     PurchaseStatus `json:"status"`
	CustomerID uuid.UUID      `json:"customer_id"`
}

// create
//
//	INSERT INTO purchase (
//	    id, status, customer_id, latest_update
//	) VALUES (
//	    uuid_generate_v4(), $1, $2, CURRENT_DATE
//	)
//	    RETURNING id, status, customer_id, latest_update
func (q *Queries) CreatePurchase(ctx context.Context, arg CreatePurchaseParams) (Purchase, error) {
	row := q.db.QueryRow(ctx, CreatePurchase, arg.Status, arg.CustomerID)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.CustomerID,
		&i.LatestUpdate,
	)
	return i, err
}

const DeletePurchase = `-- name: DeletePurchase :exec
DELETE FROM purchase
    WHERE
        id = $1
`

// delete
//
//	DELETE FROM purchase
//	    WHERE
//	        id = $1
func (q *Queries) DeletePurchase(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeletePurchase, id)
	return err
}

const ReadByPurchaseId = `-- name: ReadByPurchaseId :one
SELECT id, status, customer_id, latest_update FROM purchase
    WHERE
        id = $1
    LIMIT 1
`

// read one
//
//	SELECT id, status, customer_id, latest_update FROM purchase
//	    WHERE
//	        id = $1
//	    LIMIT 1
func (q *Queries) ReadByPurchaseId(ctx context.Context, id uuid.UUID) (Purchase, error) {
	row := q.db.QueryRow(ctx, ReadByPurchaseId, id)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.CustomerID,
		&i.LatestUpdate,
	)
	return i, err
}

const ReadPurchase = `-- name: ReadPurchase :many
SELECT id, status, customer_id, latest_update FROM purchase
    ORDER BY latest_update
`

// read many
//
//	SELECT id, status, customer_id, latest_update FROM purchase
//	    ORDER BY latest_update
func (q *Queries) ReadPurchase(ctx context.Context) ([]Purchase, error) {
	rows, err := q.db.Query(ctx, ReadPurchase)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Purchase{}
	for rows.Next() {
		var i Purchase
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CustomerID,
			&i.LatestUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdatePurchase = `-- name: UpdatePurchase :one
UPDATE purchase
SET
    status = $2,
    customer_id = $3,
    latest_update = CURRENT_DATE

    WHERE
        id = $1
    RETURNING id, status, customer_id, latest_update
`

type UpdatePurchaseParams struct {
	ID         uuid.UUID      `json:"id"`
	Status     PurchaseStatus `json:"status"`
	CustomerID uuid.UUID      `json:"customer_id"`
}

// update
//
//	UPDATE purchase
//	SET
//	    status = $2,
//	    customer_id = $3,
//	    latest_update = CURRENT_DATE
//
//	    WHERE
//	        id = $1
//	    RETURNING id, status, customer_id, latest_update
func (q *Queries) UpdatePurchase(ctx context.Context, arg UpdatePurchaseParams) (Purchase, error) {
	row := q.db.QueryRow(ctx, UpdatePurchase, arg.ID, arg.Status, arg.CustomerID)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.CustomerID,
		&i.LatestUpdate,
	)
	return i, err
}
